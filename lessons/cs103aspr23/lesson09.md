# Lesson 9 - Python Object Oriented Programming
This lesson continues discussion of OOP in Python but we also show how to use GPT to help learn new programming concepts, like OOP.

## the GPT API
The following Python program allows you to access the [GPT API](https://platform.openai.com/docs/introduction/overview) from Python.
To use it you will need to get an API key from openAI.com as mentioned in the comment

``` python
'''
Demo code for interacting with GPT-3 in Python.
This code comes from an article on medium.com
https://medium.com/codingthesmartway-com-blog/how-to-use-chatgpt-with-python-1213b8477f7b

To run this you need to 
* first visit openai.com and get an APIkey, which you insert into the code below.
  get the apikey at this URL https://platform.openai.com/account/api-keys
* next create a folder and put this file in the folder as gpt_demo.py
* finally run the following commands

% pip3 install openai  (on Mac, or pip install openai on Windows/Linux)
% python3 gpt_demo.py  (on Mac, or python gptapi.py on Windows/Linux)

The program will ask for a prompt, send it to openAI, get the response, and print it.
'''
import openai

# Set up the OpenAI API client
openai.api_key = "YOUR_API_KEY"

# test for an API key
if openai.api_key=="YOUR_API_KEY":
    print("You need to get an openapi api key to use this demo")
    exit()

# Set up the model and prompt
model_engine = "text-davinci-003"
prompt = input("Enter a prompt: ") # "Hello, how are you today?"

# Generate a response
completion = openai.Completion.create(
    engine=model_engine,
    prompt=prompt,
    max_tokens=1024,
    n=1,
    stop=None,
    temperature=0.5,
)

response = completion.choices[0].text
print(response)
```

This allows you to run gpt queries from your command line and not have to open up a browser....
Here are a few examples of its use.

## creating the BankAccount class demo
When using an AI chatbot to learn a new programming language,
make sure that you try to understand everyone of code!  You should
also trace through simple programs by hand or using pythontutor.com
to see how the code works on a line-by-line level.

Note that, like wikipedia, you can not trust anything the chatbot
produces, no matter how correct it looks. You need to be highly skeptical.

The following example produces almost the same code as we showed last week
(but I didn't ask it to write a transfer method).

``` python
'''
This code was generated by GPT-3 in response to the following query:
 % python3 gptapi.py
Enter a prompt: How would you create a simple BankAccount class in Python to deposit and withdraw funds and get the balance?
'''

class BankAccount:
    def __init__(self, balance):
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        self.balance -= amount
        return self.balance

    def get_balance(self):
        return self.balance

# Usage:

account = BankAccount(100)
account.deposit(50)
account.withdraw(25)
print(account.get_balance()) # 125
```

## implementing a simple shell in Python
Here is another example where we ask chatGPT to implement a simple shell in Python.
By studying the code we can learn how to implement a shell and it also shows us 
which new packages we might want to learn (in this case the ["os" package](https://docs.python.org/3/library/os.html)).

``` python
#!/usr/bin/python3

'''
my_gpt_demo.py 
Enter a prompt: Write a Python program to implement a simple shell to process the ls, cd, pwd, and mkdir commands
'''

import os

def my_shell():
    while True:
        command = input("$ ").split()
        if len(command) == 0:
            continue
        if command[0] == "ls":
            os.system("ls")
        elif command[0] == "cd":
            if len(command) > 1:
                os.chdir(command[1])
            else:
                os.chdir(os.environ['HOME'])
        elif command[0] == "pwd":
            print(os.getcwd())
        elif command[0] == "mkdir":
            if len(command) > 1:
                os.mkdir(command[1])
            else:
                print("Error: No directory name specified")
        elif command[0] == "exit":
            break
        else:
            print("Error: command not found")

if __name__=='__main__':
    my_shell()


```

## Python Programming Style
The Python developer community has agreed on a comprehensive style guide
You can check if your programs follow that guide using the pylint command
and you can get more information about the warnings it generates at the [pylint message page](https://pylint.readthedocs.io/en/latest/user_guide/messages/index.html)

Visit the [pylint website](https://pylint.readthedocs.io/en/latest/index.html) to see how to install and run pylint on your code. 
You should run pylint on all of your python programs in this class.

## Python Documentation
We can use the [pydoc module](https://docs.python.org/3/library/pydoc.html) to generate a nice documentation page 
for any of our modules, e.g.
``` bash
% python3 -m pydoc bank_account.py | less
```
will generate documentation on the bank_account module if you have written it and its in the current working directory.

# Object-Oriented Programming in Python
In this part of the lesson we read through the [official Python Tutorial chapter on Classes](https://docs.python.org/3/tutorial/classes.html) 

Learning to use programming features by reading documentation is a skill we want you to learn in this class.
Today we'll demonstrate how to go about learning a feature by reading the documentation and exploring it in real time
with Python tutor and the Python shell and Visual Studio Code.

## Why create and use objects to solve problems?
Why not just use functions? We'll have a discussion about this.
Some of the main reasons are:
* information hiding 
* namespace handling (but modules do that too)
* reducing redunancy through inheritance
* overloading operators (Python let's you define multiplication addition etc of your own objects.

## Quaternion example
Here is an example of the Quaternion class, created with the help of github copilot
``` python
import math

class Quaternion():
    '''
      this implements quaternion arithmetic
    '''
    def __init__(self, w, x, y, z):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        return "Quaternion(%s, %s, %s, %s)" % (self.w, self.x, self.y, self.z)  

    def __add__(self, other):
        return Quaternion(self.w + other.w, self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Quaternion(self.w - other.w, self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __mul__(self, other):
        return Quaternion(self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
                          self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
                          self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
                          self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w)

    def __div__(self, other):
        return self * other.inverse()
    
    def __eq__(self, other):
        return self.w == other.w and self.x == other.x and self.y == other.y and self.z == other.z
    
    def __ne__(self, other):
        return not self == other
    
    def __abs__(self):
        return math.sqrt(self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z)
    
    def __neg__(self):
        return Quaternion(-self.w, -self.x, -self.y, -self.z)
    
    def __pos__(self):
        return self

    def __invert__(self):
        return self.inverse()

    def __nonzero__(self):
        return self.w != 0 or self.x != 0 or self.y != 0 or self.z != 0
    
    
    def __cmp__(self, other):
        return cmp((self.w, self.x, self.y, self.z), (other.w, other.x, other.y, other.z))
    
    def __repr__(self):
        return "Quaternion(%s, %s, %s, %s)" % (self.w, self.x, self.y, self.z)
    
    def __call__(self, w, x, y, z):
        return Quaternion(w, x, y, z)
    
    def inverse(self):
        return Quaternion(self.w, -self.x, -self.y, -self.z) / abs(self)

    def conjugate(self):
        return Quaternion(self.w, -self.x, -self.y, -self.z)
    
    def normalize(self):
        return self / abs(self)
 
    def toTuple(self):
        '''
          this converts a quaternion to a tuple
        '''
        return (self.w, self.x, self.y, self.z)
    
    def toList(self):
        '''
          this converts a quaternion to a list
        '''
        return [self.w, self.x, self.y, self.z]
    
    def toDict(self):
        '''
          this converts a quaternion to a dict
        '''
        return {'w': self.w, 'x': self.x, 'y': self.y, 'z': self.z}
    

if __name__=='__main__':
    q=Quaternion(0,1,1,1)*Quaternion(1/math.sqrt(3),0,0,0)
    print('q',q)
    print('q**2',q*q)
```

and here is an example of using the Quaternion class to rotate 3d vectors 
a given angle around an axis of rotation. This is very commonly used in 3d graphics and games.
``` python
'''
this implements 3D rotations using Quaternionic conjugation 
to calculate the Rodriguez Rotation formula in 3d
'''

import math
from quaternion import *

class Vector3():
    ''' this represents 3d vectors '''
    def __init__(self,x,y,z):
        ''' store the 3 components in instance variables'''
        self.x=x
        self.y=y
        self.z=z
    
    def __str__(self):
        ''' return a string in the standard form (x,y,z) '''
        return f'({self.x},{self.y},{self.z})'



class Rotation():
    '''
        this represents rotations in 3d space
        by specifying a vector to rotate around (the axis of rotation) (x,y,z)
        and the angle to rotate around that vector 
        (counter clockwise looking down the vector)
        The rotations are represented by a quaternion
        and the rotation is performed by a conjugation v' = q*v*q'
        where v is a pure imaginary quaternion and v' is its rotation.
    '''
    def __init__(self,q=Quaternion(1,0,0,0)):
        ''' initialize the rotation with the identity quaternion, or some other one'''
        self.q=q

    def set_rotation(self,angle,x,y,z):
        ''' create a rotation of angle degrees around axis (x,y,z) 
            and use that to form a unit quaternion   
        '''
        radians = angle/180*math.pi
        c = math.cos(radians/2)
        s = math.sin(radians/2)
        d = math.sqrt(x*x+y*y+z*z)
        self.q = Quaternion(c,s*x/d,s*y/d,s*z/d)
        return self
    
    def __str__(self):
        ''' print a rotation by finding the angle and unit vector in 3d space from the quaternion '''
        angle = math.acos(self.q.w)
        s=math.sin(angle)
        if s!=0:
            return(f'{2*angle/math.pi*180} degrees around({self.q.x/s},{self.q.y/s},{self.q.z/s}).')
        else:
            return('identity rotation')
    
    def __mul__(self, other):
        ''' compose two rotations by multiplying their quaternions !! '''
        return Rotation(self.q*other.q)
    
    def rotate(self,vector):
        ''' rotate a vector around an axis by conjugating it with the rotation quaternion '''
        v = Quaternion(0,vector.x,vector.y,vector.z)
        q1 = self.q*v*self.q.conjugate()
        #print(q1)
        return Vector3(q1.x,q1.y,q1.z)


if __name__=='__main__':
    '''
        this demo shows how to use quaternions to rotate vectors with quaternion conjugation
    ''' 

    print('rotate v=(1,2,3) by 120 degrees around (1,1,1) three times to get w1, w2, and w3')
    v = Vector3(1,2,3)
    r = Rotation().set_rotation(120,1,1,1)
    w = r.rotate(v)
    w2 = r.rotate(w)
    w3 = r.rotate(w2)
    print('r=',r)
    print('v=',v)
    print('w1=',w)
    print('w2=',w2)
    print('w3=',w3)
    print()
    
    print('rotate (1,1,1) 180 degrees around the y axis to get')
    v = Vector3(1,1,1)
    r = Rotation().set_rotation(180,0,1,0)
    print(r.rotate(v))
    print()

    print('rotate (1,0,0) 45 degrees counterclockwise around y axis to get:')
    print(Rotation().set_rotation(45,0,1,0).rotate(Vector3(1,0,0)))
    print()

    print('cube the rotation by 120 around (1,1,1) to get the identity')
    r = Rotation().set_rotation(120,1,1,1)
    print('r^3=',r*r*r)
    print('r^3.q=',(r*r*r).q)
```

