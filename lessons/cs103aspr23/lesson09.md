# Lesson 9 - Python Object Oriented Programming
This lesson continues discussion of OOP in Python but we also show how to use GPT to help learn new programming concepts, like OOP.

## the GPT API
The following Python program allows you to access the [GPT API](https://platform.openai.com/docs/introduction/overview) from Python.
To use it you will need to get an API key from openAI.com as mentioned in the comment

``` python
'''
Demo code for interacting with GPT-3 in Python.
This code comes from an article on medium.com
https://medium.com/codingthesmartway-com-blog/how-to-use-chatgpt-with-python-1213b8477f7b

To run this you need to 
* first visit openai.com and get an APIkey, which you insert into the code below.
  get the apikey at this URL https://platform.openai.com/account/api-keys
* next create a folder and put this file in the folder as gpt_demo.py
* finally run the following commands

% pip3 install openai  (on Mac, or pip install openai on Windows/Linux)
% python3 gpt_demo.py  (on Mac, or python gptapi.py on Windows/Linux)

The program will ask for a prompt, send it to openAI, get the response, and print it.
'''
import openai

# Set up the OpenAI API client
openai.api_key = "YOUR_API_KEY"

# test for an API key
if openai.api_key=="YOUR_API_KEY":
    print("You need to get an openapi api key to use this demo")
    exit()

# Set up the model and prompt
model_engine = "text-davinci-003"
prompt = input("Enter a prompt: ") # "Hello, how are you today?"

# Generate a response
completion = openai.Completion.create(
    engine=model_engine,
    prompt=prompt,
    max_tokens=1024,
    n=1,
    stop=None,
    temperature=0.5,
)

response = completion.choices[0].text
print(response)
```

This allows you to run gpt queries from your command line and not have to open up a browser....
Here are a few examples of its use.

## creating the BankAccount class demo
When using an AI chatbot to learn a new programming language,
make sure that you try to understand everyone of code!  You should
also trace through simple programs by hand or using pythontutor.com
to see how the code works on a line-by-line level.

Note that, like wikipedia, you can not trust anything the chatbot
produces, no matter how correct it looks. You need to be highly skeptical.

The following example produces almost the same code as we showed last week
(but I didn't ask it to write a transfer method).

``` python
'''
This code was generated by GPT-3 in response to the following query:
 % python3 gptapi.py
Enter a prompt: How would you create a simple BankAccount class in Python to deposit and withdraw funds and get the balance?
'''

class BankAccount:
    def __init__(self, balance):
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        return self.balance

    def withdraw(self, amount):
        self.balance -= amount
        return self.balance

    def get_balance(self):
        return self.balance

# Usage:

account = BankAccount(100)
account.deposit(50)
account.withdraw(25)
print(account.get_balance()) # 125
```

## implementing a simple shell in Python
Here is another example where we ask chatGPT to implement a simple shell in Python.
By studying the code we can learn how to implement a shell and it also shows us 
which new packages we might want to learn (in this case the ["os" package](https://docs.python.org/3/library/os.html)).

``` python
#!/usr/bin/python3

'''
my_gpt_demo.py 
Enter a prompt: Write a Python program to implement a simple shell to process the ls, cd, pwd, and mkdir commands
'''

import os

def my_shell():
    while True:
        command = input("$ ").split()
        if len(command) == 0:
            continue
        if command[0] == "ls":
            os.system("ls")
        elif command[0] == "cd":
            if len(command) > 1:
                os.chdir(command[1])
            else:
                os.chdir(os.environ['HOME'])
        elif command[0] == "pwd":
            print(os.getcwd())
        elif command[0] == "mkdir":
            if len(command) > 1:
                os.mkdir(command[1])
            else:
                print("Error: No directory name specified")
        elif command[0] == "exit":
            break
        else:
            print("Error: command not found")

if __name__=='__main__':
    my_shell()


```

## Python Programming Style
The Python developer community has agreed on a comprehensive style guide
You can check if your programs follow that guide using the pylint command
and you can get more information about the warnings it generates at the [pylint message page](https://pylint.readthedocs.io/en/latest/user_guide/messages/index.html)

Visit the [pylint website](https://pylint.readthedocs.io/en/latest/index.html) to see how to install and run pylint on your code. 
You should run pylint on all of your python programs in this class.

## Python Documentation
We can use the [pydoc module](https://docs.python.org/3/library/pydoc.html) to generate a nice documentation page 
for any of our modules, e.g.
``` bash
% python3 -m pydoc bank_account.py | less
```
will generate documentation on the bank_account module if you have written it and its in the current working directory.

# Object-Oriented Programming in Python
In this part of the lesson we read through the [official Python Tutorial chapter on Classes](https://docs.python.org/3/tutorial/classes.html) 

Learning to use programming features by reading documentation is a skill we want you to learn in this class.
Today we'll demonstrate how to go about learning a feature by reading the documentation and exploring it in real time
with Python tutor and the Python shell and Visual Studio Code.

## Why create and use objects to solve problems?
Why not just use functions? We'll have a discussion about this.
Some of the main reasons are:
* information hiding - 
    * the user only needs to know how to use the class, not how it is implemented
    * this allows us to change the implementation without breaking anyone's code
* namespace handling 
    * by defining methods instead of function there is less danger of redefining one of the user's own functions
* reducing redunancy through inheritance
    * as in Java
* overloading operators (Python let's you define multiplication addition etc of your own objects.
    * Python lets us define methods to handle standard arithmetic operators on our own objects, e.g. multiplying objects!

## Quaternion example
Here is an example of the Quaternion class, created with the help of github copilot.

The ``` __ZZZ___``` methods correspond to special methods, e.g. 

```__add__``` is called when it evaluates ```q1+q2```
and 

```__eq__``` is called when it evaluates the condition ```q1==q2```. 

This allows for operator overloading
which can make your code much easier to read when it applies.

You can learn more about quaternions at the [Wolfram quaternion page](https://mathworld.wolfram.com/Quaternion.html)
and by reading the module comment. These are interesting mathematical objects and very useful in 3d graphics and game engines.




``` python
'''
    The Quaternion class represents elements of Hamilton's quanterions.

    Quaternions are like complex numbers a+bi 
    but they have two more imaginary values j,k with 
    i^2 = j^2 = k^2 = ijk = -1
    and ij=k=-ji, jk=i=-kj, ki=j=-ik 
    So they have the form a+bi+cj+dk and are associative and non-commutative.

    author: Tim Hickey and chatGPT
    date: 2/5/2023

    reference: https://mathworld.wolfram.com/Quaternion.html

'''
import math

class Quaternion():
    '''
      a quaternion: r+xi+yj+zk  where i,j,k are imaginary and r,a,b,c are real

      Attributes:
        w: the real part
        x: the coefficient of i
        y: the coefficient of j
        z: the coefficiant of k

    '''
    def __init__(self, w, x, y, z):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        ''' return a readable version in the form r + ai + bj + ck'''
        return "%s +%s i+ %sj + %sk" % (self.w, self.x, self.y, self.z)  
    
    def __repr__(self):
        ''' return a version that can be used to reconstruct itself, i.e. the constructor '''
        return "Quaternion(%s, %s, %s, %s)" % (self.w, self.x, self.y, self.z) 

    def __add__(self, other):
        ''' return the sum of this quaternion with the other  q+p'''
        return Quaternion(self.w + other.w, self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        ''' return the difference of this quaternion with the other  q-p '''
        return Quaternion(self.w - other.w, self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __mul__(self, other):
        ''' return the product of this quaternion with the other  q*p'''
        return Quaternion(self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
                          self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
                          self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
                          self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w)

    def __div__(self, other):
        ''' return the quotient of this quaternion by the other  q/p'''
        return self * other.inverse()
    
    def __eq__(self, other):
        ''' test for equality q==r'''
        return self.w == other.w and self.x == other.x and self.y == other.y and self.z == other.z
    
    def __ne__(self, other):
        ''' test for inequality q!=r '''
        return not self == other
    
    def __abs__(self):
        ''' return the length of q ... abs(q)'''
        return math.sqrt(self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z)
    
    def __neg__(self):
        ''' return the negation of q ... -q '''
        return Quaternion(-self.w, -self.x, -self.y, -self.z)
    
    def __pos__(self):
        ''' return q for the expression +q'''
        return self

    def __nonzero__(self):
        ''' test that q!=0 '''
        return self.w != 0 or self.x != 0 or self.y != 0 or self.z != 0
    
    def __cmp__(self, other):
        ''' returns cpm(self,other) 
            is positive if self>other, negative if self<other, zero if self==other
            compared as a tuple of numbers, lexicographically
        
        '''
        return cmp((self.w, self.x, self.y, self.z), (other.w, other.x, other.y, other.z))
    
    
    def __call__(self, w, x, y, z):
        ''' this lets a quaternion act as a constructor
            q = Quaternion(1,0,0,0)
            q1 = q(0,1,0,0) # makes a new quaternion and doesn't change q
        '''
        return Quaternion(w, x, y, z)
    
    def inverse(self):
        ''' returns 1/self '''
        return Quaternion(self.w, -self.x, -self.y, -self.z) / abs(self)

    def conjugate(self):
        ''' (w+ai+bj+ck).conjugate() -> w-ai-bj-ck '''
        return Quaternion(self.w, -self.x, -self.y, -self.z)
    
    def normalize(self):
        ''' maps self into a unit quaternion, i.e. one of length 1'''
        d = abs(self)
        return Quaternion(self.w/d, self.x/d, self.y/d, self.z/d)
 
    def toTuple(self):
        '''
          this converts a quaternion to a tuple
        '''
        return (self.w, self.x, self.y, self.z)
    
    def toList(self):
        '''
          this converts a quaternion to a list
        '''
        return [self.w, self.x, self.y, self.z]
    
    def toDict(self):
        '''
          this converts a quaternion to a dict
        '''
        return {'w': self.w, 'x': self.x, 'y': self.y, 'z': self.z}
    

if __name__=='__main__':
    q=Quaternion(0,1,1,1).normalize()
    print("\n\nhere is a purely imaginary quaternion q of length 1, these always square to -1")
    print('q =',q)
    print('q**2 = ',q*q)
     
```

## Using Quaterions to rotate vectors in 3d space
Here is an example of using the Quaternion class to rotate 3d vectors 
a given angle around an axis of rotation. This is very commonly used in 3d graphics and games.

First we need to define the Vector3 class
``` python
'''
  Vector 3 is a 3 dimensional vector of floats
'''

class Vector3():
    ''' this represents 3d vectors '''
    def __init__(self,x,y,z):
        ''' store the 3 components in instance variables'''
        self.x=x
        self.y=y
        self.z=z
    
    def __str__(self):
        ''' return a string in the standard form (x,y,z) '''
        return f'({self.x},{self.y},{self.z})'
    
    def __repr__(self):
        ''' return a string in the form of a constructor'''
        return f'(Vector3({self.x},{self.y},{self.z})'


```

Now we can use it in the Rotation class. Note this also gives an example
of a static method used as a factory to create new Rotations without a constructor.


``` python
'''
a general rigid body rotation in 3 dimensions

this implements 3D rotations using Quaternionic conjugation
to calculate the Rodriguez Rotation formula in 3d
and it uses quaternion multiplication to compose rotations
'''

import math
from quaternion import Quaternion
from vector import Vector3



class Rotation_3d():
    '''
        this represents rotations in 3d space

        by specifying a vector to rotate around (the axis of rotation) (x,y,z)
        and the angle to rotate around that vector
        (counter clockwise looking down the vector)

        The rotations are represented by a quaternion
        and the rotation is performed by a conjugation v' = q*v*q'
        where v is a pure imaginary quaternion and v' is its rotation.

        Attributes:
            q: the unit quaternion of the form (c,s*a,s*b,s*c)
            where c=cos(2t), s=sin(t2) and
            the rotation is t degrees around the axis of rotation (a,b,c)
    '''
    def __init__(self,q=Quaternion(1,0,0,0)):
        ''' initialize the rotation with the identity quaternion, or some other one'''
        self.q=q

    def set_rotation(self,angle,x,y,z):
        ''' create a rotation of angle degrees around axis (x,y,z)
            and use that to form a unit quaternion
            This is a factory method .. it creates an object, but isn't a constructor.
        '''
        radians = angle/180*math.pi
        c = math.cos(radians/2)
        s = math.sin(radians/2)
        d = math.sqrt(x*x+y*y+z*z)
        self.q = Quaternion(c,s*x/d,s*y/d,s*z/d)
        return self

    @staticmethod
    def rotation(angle,x,y,z):
        ''' return a rotation of angle degrees around axis (x,y,z)

            this is a static method called as
            r = Rotation_3d.rotation(45,0,1,0)
        '''
        radians = angle/180*math.pi
        c = math.cos(radians/2)
        s = math.sin(radians/2)
        d = math.sqrt(x*x+y*y+z*z)
        return Rotation_3d(Quaternion(c,s*x/d,s*y/d,s*z/d))

    def __str__(self):
        ''' print a rotation by finding the angle
            and unit vector in 3d space from the quaternion '''
        angle = math.acos(self.q.w)
        s=math.sin(angle)
        if s!=0:
            return f'{2*angle/math.pi*180} degrees around({self.q.x/s},{self.q.y/s},{self.q.z/s}).'
        return 'identity rotation'

    def __mul__(self, other):
        ''' compose two rotations by multiplying their quaternions !! '''
        return Rotation_3d(self.q*other.q)

    def rotate(self,vector):
        ''' rotate a vector around an axis by conjugating it with the rotation quaternion '''
        v = Quaternion(0,vector.x,vector.y,vector.z)
        q1 = self.q*v*self.q.conjugate()
        return Vector3(q1.x,q1.y,q1.z)

def test_code():
    ''' this demo shows how to use quaternions to rotate vectors with quaternion conjugation '''

    print('rotate v=(1,2,3) by 120 degrees around (1,1,1) three times to get w1, w2, and w3')
    v = Vector3(1,2,3)
    r = Rotation_3d.rotation(120,1,1,1)  # here we use a static method to create a rotation object
    w1 = r.rotate(v)
    w2 = r.rotate(w1)
    w3 = r.rotate(w2)
    print('rotation=',r)
    print('v=',v)
    print('w1=',w1)
    print('w2=',w2)
    print('w3=',w3)
    print()

    print('rotate (1,1,1) 180 degrees around the y axis to get (-1,1,-1)')
    v = Vector3(1,1,1)
    r = Rotation_3d.rotation(180,0,1,0)
    print(r.rotate(v))
    print()

    print('rotate (1,0,0) 45 degrees counterclockwise around y axis')
    print('to get: (sqrt(1/2),0,-sqrt(1/2))')
    print(Rotation_3d.rotation(45,0,1,0).rotate(Vector3(1,0,0)))
    print()

    print('cube the rotation by 120 around (1,1,1) to get the identity 1+0i+0j+0k')
    r = Rotation_3d.rotation(120,1,1,1)
    print('r^3=',r*r*r)
    print('r^3.q=',(r*r*r).q)

if __name__=='__main__':
    test_code()


```

